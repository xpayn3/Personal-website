(function(){
    var contentArrays = [],
    shuffleArrays = [],
    scaleWidths = [],
    widthTypes = [],
    cycles = [],
    counter = 0,
    loops = [],
    transform_containers = [],
    transform_wrappers = [],
    isFixed = [],
    waitForError = [],
    show_durations = [],
    hide_durations = [];

    var buildCycle = function(){
      // Grab all cycles from DOM...
      cycles = document.querySelectorAll(".cycle");
       _.each(cycles, function(cycle, index){
            if ( !cycle.classList.contains("initialized") ){
              // remove non-text from cycle
              var media = cycle.querySelectorAll('video, img, div.audio-player');
              _.each(media, function(item){
                if ( item.parentNode){
                  item.parentNode.removeChild(item)  
                }
              });

              var content = cycle.innerHTML;
              var inner = document.createElement("div");
              var outer = document.createElement("div");

              inner.className = "cycle_content";
              outer.className = "cycle_container";

              var separator = cycle.hasAttribute('separator') ? cycle.getAttribute('separator') : " ";
              
              if ( !cycle.hasAttribute("size") ){
                scaleWidths[index] = 90;
              } else {
                var val = cycle.getAttribute("size");
                if ( val.indexOf("rem") >= 0){
                  val = val.split("rem");
                  val = val[0]
                  widthTypes[index] = "rem";
                  isFixed[index] = true
                } else if ( val.indexOf("%") >= 0 ){
                  val = val.split("%");
                  val = val[0];
                  widthTypes[index] = "%";
                  isFixed[index] = false
                } else {
                  isFixed[index] = false
                  widthTypes[index] = "%";
                  val = 90;
                }
                var int = parseFloat( val );
                scaleWidths[index] = int
              }

              assignBools(cycle, "loop", loops, index, true);
              assignBools(cycle, "random", shuffleArrays, index, false);
              assignValues(cycle, "on-time", show_durations, index, 1000 )
              assignValues(cycle, "off-time", hide_durations, index, 100 )

              cycle.innerHTML = "";

              // Set index number for teardown
              outer.setAttribute("index_num", index);
              outer.setAttribute("contenteditable", false);
              inner.setAttribute("contenteditable", false);

              transform_containers[index] = inner
              transform_wrappers[index] = outer
              
              contentArrays[index] = content.split(separator);
              cycle.parentNode.replaceChild(outer, cycle)
              outer.appendChild(inner);
              cycle.classList.add("initialized");
            }

       });
       animateCycle(transform_containers)
    };

    var debounceBuild = _.debounce(buildCycle, 500);
    
    var assignValues = function(cycle, name, store, index, dflt){
      if( !cycle.hasAttribute(name) ) {
        store[index] = dflt
      } else {
        var val = parseFloat( cycle.getAttribute(name) )
        store[index] = val
      }
    }

    var assignBools = function(cycle, name, store, index, dflt){
      if( !cycle.hasAttribute(name) ){
        store[index] = dflt
      } else {
        var val = cycle.getAttribute(name);
        var bool = (val == 'true');
        if(bool){
          store[index] = true
        } else {
          store[index] = false
        }
      }
    }

    var setElementSize = function(){
      _.each(transform_containers, function(elem, index){
          var w_width = window.innerWidth
          var w_height = window.innerHeight
          var set_size = scaleWidths[index];
          if( isFixed[index] == true ){
            elem.style["fontSize"] = set_size+"rem"
            // we add transform so double animation check works as intended.
            elem.style.transform = "scale(1)"
            return
          } else {
            if(set_size >= 0 ){
              w_width = w_width * (set_size * 0.01);
            }
            var scaleX = w_width/elem.offsetWidth;
            var scaleY = w_height/elem.offsetHeight;
            elem.style["transform"] = "scale("+Math.min(scaleX, scaleY)+")"
          }
        });
    }

    var shuffle = function(array) {
      var currentIndex = array.length, temporaryValue, randomIndex;
      // While there remain elements to shuffle...
      while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }
      return array;
    }

    var animateCycle = function(containers){
      _.each(containers, function(elem, index){
        var style = elem.style
        // if our style object contains transform, it's already being animated.
        if ( Object.values(style).indexOf('transform') > -1 ){
          return
        }

        var loop_counter = 0
        var text = contentArrays[index];
        var show_for = show_durations[index];
        var hide_for = hide_durations[index];
        var total_time = show_for + hide_for;
        // Do an initial change.
        change()
        // Create
        var inst = setInterval(change, total_time);
        // Shuffle text array if applicable.
        if(shuffleArrays[index]){ text = shuffle(text) }
        function change() {
          if( text == undefined ){return}
          elem.innerHTML = text[loop_counter];
          _.debounce( setElementSize(), 300);
          elem.style["opacity"] = "1"
          if(hide_for != 0){
            setTimeout(function(){
              elem.style["opacity"] = "0"
            }, show_for)
          }
          loop_counter++;
          if(loop_counter >= text.length) {
            if(!loops[index]){ 
              clearInterval(inst)
              setTimeout(function(){
              elem.style["opacity"] = "1"
              }, show_for)
            }
            if(shuffleArrays[index]){ text = shuffle(text) }
            loop_counter = 0;
          }
        }

      });
      counter++;
    }

    // This function allows editing of the Cycle in Code View.
    var tearDownForEditor = function(){
      // Only perform this action in main container.
      var mainContainer = document.querySelector('.main_container');
      if(!mainContainer){
        return;
      }

      var built_cycles = mainContainer.querySelectorAll('.cycle_container');
      if(transform_wrappers && built_cycles != undefined ){
        _.each(transform_wrappers, function(cycle){
          // Get index number so everything stays in order.
          var number = cycle.attributes.getNamedItem("index_num").value
          var cycle_in_DOM = mainContainer.querySelectorAll(".cycle_container[index_num='"+number+"']");

          if( cycle_in_DOM[0] && cycle_in_DOM[0] != undefined && cycle_in_DOM[0] != null ){
            if(cycle.parentNode != null && cycle.parentNode != undefined ){
              var cycle_in_DOM = cycle_in_DOM[0];           
              // Recreate originally entered HTML using stored arrays
              var pseudo_cycle = document.createElement("div");
              var string = contentArrays[number].join(" ");
              var scaleUnit = scaleWidths[number] + widthTypes[number]
              pseudo_cycle.className = 'cycle';
              pseudo_cycle.setAttribute('on-time', show_durations[number])
              pseudo_cycle.setAttribute('off-time', hide_durations[number])
              pseudo_cycle.setAttribute('size', scaleUnit )
              pseudo_cycle.setAttribute('random', shuffleArrays[number])
              pseudo_cycle.setAttribute('loop', loops[number])
              pseudo_cycle.innerHTML = string
              // CodeMirror will not recgonize your new DOM nodes w/o these.
              pseudo_cycle.saveable = true;
              CargoEditor.helpers.getAllDescendants(pseudo_cycle, function(node){
              node.saveable = true;
              });
              // Finally replace animated element with cycle. 
              cycle.parentNode.replaceChild(pseudo_cycle, cycle );
              pseudo_cycle.saveable = true;
            }
          }
        })
      }
    }

    var init = function(){
        buildCycle();
        var isAdmin = Cargo.Helper.IsAdminEdit()
        // If we're in the admin, listen for Code View opening. 
        if ( isAdmin ){ 
          Cargo.Event.on('cargoEditor:before-html-to-projectcontent', function(){
            tearDownForEditor();
            debounceBuild();
          });
        }
    }
    // Spray init all over. Duplicate calls won't matter, but unanimated cycles will...
    setTimeout(function(){ init }, 100)
    Cargo.Event.on("image_gallery_init_complete", init );
    Cargo.Event.on('pageview_removed', init );
    Cargo.Event.on('pin_format_complete', init );
    Cargo.Event.on('pin_format_complete', init );
    Cargo.Event.on('image_gallery_init_complete', init );  
})();